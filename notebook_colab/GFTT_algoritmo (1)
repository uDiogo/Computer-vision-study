{"cells":[{"cell_type":"code","execution_count":1,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":1000,"output_embedded_package_id":"1lz_5rr_oNLMZVjFSi0ApzDeuHNzqbzYs"},"id":"6a7AJKe0N6T8","executionInfo":{"status":"ok","timestamp":1763080284786,"user_tz":180,"elapsed":10422,"user":{"displayName":"Diogo Souza","userId":"00513206853723505463"}},"outputId":"b4454766-7335-4d08-ded5-0ef07bf1c935"},"outputs":[{"output_type":"display_data","data":{"text/plain":"Output hidden; open in https://colab.research.google.com to view."},"metadata":{}}],"source":["import numpy as np\n","import cv2\n","import time\n","import sys\n","from google.colab import files\n","from google.colab.patches import cv2_imshow\n","import io\n","from PIL import Image\n","\n","# --- Função de Teste Modificada (Apenas OpenCV) ---\n","\n","def visualTest(color_img, img, maxCor, thresh, dst):\n","    \"\"\"\n","    Executa a detecção de cantos com a função nativa (cv2)\n","    e exibe os resultados no Colab.\n","    \"\"\"\n","\n","    # Teste da implementação nativa (Built-in Shi-Tomasi)\n","    try:\n","        print(\"\\nExecutando função 'cv2.goodFeaturesToTrack'...\")\n","        start_time = time.time()\n","        # Garante que os argumentos numéricos sejam tipos Python nativos\n","        builtInCorners_float = cv2.goodFeaturesToTrack(img, int(maxCor), float(thresh), int(dst))\n","        end_time = time.time()\n","\n","        if builtInCorners_float is not None:\n","            builtInCorners = np.int32(builtInCorners_float)\n","\n","            print(f\"Função nativa encontrou {len(builtInCorners)} cantos em {end_time - start_time:.6f} segundos.\")\n","\n","            tmpImage_builtin = color_img.copy()\n","            for corner in builtInCorners:\n","                x, y = corner.ravel()\n","                cv2.circle(tmpImage_builtin, (x, y), 3, (0, 255, 0), -1) # Cantos em Verde\n","\n","            print(\"Resultado de 'cv2.goodFeaturesToTrack':\")\n","            cv2_imshow(tmpImage_builtin)\n","        else:\n","            print(\"Função nativa (cv2.goodFeaturesToTrack) não encontrou cantos.\")\n","\n","    except Exception as e:\n","        print(f\"Erro ao executar 'cv2.goodFeaturesToTrack': {e}\")\n","\n","# --- Funções Auxiliares do Colab ---\n","\n","def load_image_from_upload(file_dict):\n","    \"\"\"\n","    Carrega uma imagem a partir de um arquivo enviado via files.upload().\n","    Retorna a imagem em formato BGR (padrão OpenCV).\n","    \"\"\"\n","    if not file_dict:\n","        print(\"Nenhuma imagem enviada.\")\n","        return None\n","\n","    try:\n","        # Pega o primeiro arquivo enviado\n","        filename = list(file_dict.keys())[0]\n","        file_data = file_dict[filename]\n","\n","        # Converte os bytes para uma imagem PIL\n","        pil_image = Image.open(io.BytesIO(file_data))\n","\n","        # Converte a imagem PIL para um array NumPy\n","        # PIL (RGB ou RGBA) -> OpenCV (BGR)\n","        color_img_np = np.array(pil_image)\n","\n","        if len(color_img_np.shape) == 3 and color_img_np.shape[2] == 4:\n","            # Converte RGBA para BGR\n","            color_img = cv2.cvtColor(color_img_np, cv2.COLOR_RGBA2BGR)\n","        elif len(color_img_np.shape) == 3:\n","            # Converte RGB para BGR\n","            color_img = cv2.cvtColor(color_img_np, cv2.COLOR_RGB2BGR)\n","        elif len(color_img_np.shape) == 2:\n","            # Imagem já é P&B, converte para BGR para exibição\n","            color_img = cv2.cvtColor(color_img_np, cv2.COLOR_GRAY2BGR)\n","        else:\n","            print(f\"Formato de imagem não suportado: {color_img_np.shape}\")\n","            return None\n","\n","        print(f\"Imagem '{filename}' carregada com sucesso.\")\n","        return color_img\n","\n","    except Exception as e:\n","        print(f\"Falha ao carregar a imagem: {e}\")\n","        return None\n","\n","# --- Função Principal ---\n","\n","def main():\n","    # --- 1. Upload e carregamento da Imagem de Teste ---\n","    print(\"Por favor, envie sua imagem de teste (ex: .png, .jpg)...\")\n","    uploaded_image = files.upload()\n","    color_img = load_image_from_upload(uploaded_image)\n","\n","    if color_img is None:\n","        print(\"Não é possível continuar sem uma imagem válida.\")\n","        return\n","\n","    # --- 2. Preparação da Imagem ---\n","\n","    # 'img' deve ser a versão em escala de cinza para detecção\n","    if len(color_img.shape) == 3:\n","        img = cv2.cvtColor(color_img, cv2.COLOR_BGR2GRAY)\n","    else:\n","        # Se já for P&B, 'img' é uma cópia\n","        img = color_img.copy()\n","        # E 'color_img' precisa ser convertida para 3 canais para desenhar colorido\n","        color_img = cv2.cvtColor(color_img, cv2.COLOR_GRAY2BGR)\n","\n","    # --- 3. Definição dos Parâmetros ---\n","    maxCorners = 3000 #quantidade de cantos\n","    thresh = 0.01 #limiar relativo de qualidade\n","    dist = 10  #distância mínima entre cantos\n","\n","    # --- 4. Execução do Teste Visual ---\n","    visualTest(color_img, img, maxCorners, thresh, dist)\n","\n","if __name__ == \"__main__\":\n","    main()"]}],"metadata":{"colab":{"provenance":[{"file_id":"/v2/external/notebooks/intro.ipynb","timestamp":1762970769148}]},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}